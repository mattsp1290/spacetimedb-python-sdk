"""
QueryId implementation for SpacetimeDB Python SDK.

QueryId is used to track individual subscription queries in the modern protocol.
"""

import threading
from typing import Union

from .bsatn.writer import BsatnWriter
from .bsatn.reader import BsatnReader
from .bsatn.constants import TAG_U32


class QueryId:
    """
    An opaque id generated by the client to refer to a subscription.
    This is used in Unsubscribe messages and errors.
    
    QueryId wraps a u32 integer and provides proper serialization,
    equality, and hashing for use in subscription management.
    """
    
    # Class-level counter for auto-generation
    _counter_lock = threading.Lock()
    _counter = 0
    
    def __init__(self, id: Union[int, 'QueryId']):
        """
        Create a new QueryId.
        
        Args:
            id: The u32 identifier (0 to 4294967295)
            
        Raises:
            ValueError: If id is out of u32 range
        """
        if isinstance(id, QueryId):
            self.id = id.id
        else:
            if not isinstance(id, int):
                raise ValueError(f"QueryId id must be an integer, got {type(id)}")
            if id < 0:
                raise ValueError(f"QueryId id must be non-negative, got {id}")
            if id > 4294967295:  # u32 max
                raise ValueError(f"QueryId id must be <= 4294967295 (u32 max), got {id}")
            self.id = id
    
    @classmethod
    def generate(cls) -> 'QueryId':
        """
        Generate a new unique QueryId.
        
        Returns:
            A new QueryId with an auto-generated unique id
        """
        with cls._counter_lock:
            cls._counter += 1
            # Wrap around at u32 max to stay within bounds
            if cls._counter > 4294967295:
                cls._counter = 1
            return cls(cls._counter)
    
    def __eq__(self, other) -> bool:
        """Test equality with another QueryId."""
        if not isinstance(other, QueryId):
            return False
        return self.id == other.id
    
    def __hash__(self) -> int:
        """Return hash for use in sets and dicts."""
        return hash(self.id)
    
    def __str__(self) -> str:
        """Return string representation."""
        return f"QueryId({self.id})"
    
    def __repr__(self) -> str:
        """Return detailed representation."""
        return f"QueryId(id={self.id})"
    
    def write_bsatn(self, writer: BsatnWriter) -> None:
        """
        Write this QueryId to a BSATN writer.
        
        Args:
            writer: The BSATN writer to write to
        """
        writer.write_u32(self.id)
    
    @classmethod
    def read_bsatn(cls, reader: BsatnReader) -> 'QueryId':
        """
        Read a QueryId from a BSATN reader.
        
        Args:
            reader: The BSATN reader to read from
            
        Returns:
            The decoded QueryId
        """
        tag = reader.read_tag()
        if tag != TAG_U32:
            raise ValueError(f"Expected u32 tag for QueryId, got {tag}")
        id_value = reader.read_u32()
        return cls(id_value)


# Make QueryId work with the high-level BSATN encode/decode functions
def _encode_query_id(query_id: QueryId) -> bytes:
    """Encode QueryId to BSATN bytes."""
    writer = BsatnWriter()
    query_id.write_bsatn(writer)
    if writer.error():
        raise writer.error()
    return writer.get_bytes()


def _decode_query_id(data: bytes) -> QueryId:
    """Decode QueryId from BSATN bytes."""
    reader = BsatnReader(data)
    return QueryId.read_bsatn(reader)


# Register QueryId with the BSATN system for automatic encoding/decoding
# This allows QueryId to work with the high-level encode/decode functions
try:
    from .bsatn.utils import encode_to_writer, decode_from_reader
    
    # Monkey patch the encode/decode functions to handle QueryId
    _original_encode_to_writer = encode_to_writer
    _original_decode_from_reader = decode_from_reader
    
    def _patched_encode_to_writer(value, writer):
        if isinstance(value, QueryId):
            value.write_bsatn(writer)
        else:
            _original_encode_to_writer(value, writer)
    
    def _patched_decode_from_reader(reader, expected_type=None):
        if expected_type is QueryId:
            return QueryId.read_bsatn(reader)
        else:
            return _original_decode_from_reader(reader, expected_type)
    
    # For basic encode/decode without specifying expected_type,
    # we need to handle QueryId in the main encode/decode functions
    
except ImportError:
    # BSATN utils not available yet, skip registration
    pass 